<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lonicera&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://loniceras.github.io/"/>
  <updated>2020-02-12T10:39:44.609Z</updated>
  <id>http://loniceras.github.io/</id>
  
  <author>
    <name>Lonicera</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Haskell开发环境搭建</title>
    <link href="http://loniceras.github.io/2020/02/10/Haskell%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://loniceras.github.io/2020/02/10/Haskell%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-02-10T04:43:59.000Z</published>
    <updated>2020-02-12T10:39:44.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文是在 Windows 10 操作系统下使用 <a href="https://docs.haskellstack.org/en/stable/README/" target="_blank" rel="noopener">Stack</a> 搭建基于 <a href="https://github.com/haskell/haskell-ide-engine" target="_blank" rel="noopener">Haskell IDE Engine</a> ( HIE ) 的 VSCode 开发环境的介绍. Stack ( <a href="https://github.com/commercialhaskell/stack" target="_blank" rel="noopener">GitHub页面</a> ) 是用于开发 Haskell 的一个交互平台, 可以用于安装 Haskell 的编译器和各种库, 也可以用于构建和测试项目. Stack 对库的版本管理一定程度上依赖于<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#resolver" target="_blank" rel="noopener">解析器</a>的选择, 解析器支持 <a href="https://github.com/commercialhaskell/lts-haskell" target="_blank" rel="noopener">LTS 快照</a>, <a href="https://github.com/commercialhaskell/stackage-nightly" target="_blank" rel="noopener">Stackage Nightly快照</a>等多种格式对版本进行指定, 一个快照下的一个库只能拥有一个版本号, 可在 <a href="https://www.stackage.org/" target="_blank" rel="noopener">Stackage 网站</a>上查询不同 GHC 对应的最新 LTS 快照. 更多有关 Stack 的教程可以参考<a href="https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md" target="_blank" rel="noopener">用户文档</a>. HIE 是一个针对不断增长的 Haskell 工具的一个通用接口, 它为编辑器和 IDE 提供了功能齐全的语言服务器协议服务, HIE 目前支持的最低 Stack 版本为 2.1.1, 它仍然在不断开发中.<br><a id="more"></a></p><h1 id="配置-Stack"><a href="#配置-Stack" class="headerlink" title="配置 Stack"></a>配置 Stack</h1><p>从 <a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/#windows" target="_blank" rel="noopener">Stack 官网</a> 下载 Stack 的安装包并进行安装. 安装完毕后, 以管理员身份运行 CMD , 执行 <code>stack setup</code> , 直至生成 <code>C:\sr\config.yaml</code>. 随后打断 CMD 的操作, 在 <code>config.yaml</code> 文件中进行换源, 可以使用的 Hackage 镜像有:<br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/hackage/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/hackage/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package-indices:</span><br><span class="line">  - download-prefix: http://mirrors.tuna.tsinghua.edu.cn/hackage/</span><br><span class="line">  hackage-security:</span><br><span class="line">    keyids:</span><br><span class="line">    - 0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d</span><br><span class="line">    - 1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42</span><br><span class="line">    - 280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833</span><br><span class="line">    - 2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201</span><br><span class="line">    - 2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3</span><br><span class="line">    - 51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921</span><br><span class="line">    - 772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d</span><br><span class="line">    - aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9</span><br><span class="line">    - fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0</span><br><span class="line">    key-threshold: 3 # number of keys required</span><br><span class="line"></span><br><span class="line">    # ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614</span><br><span class="line">    ignore-expiry: no</span><br></pre></td></tr></table></figure><br><a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#package-indices" target="_blank" rel="noopener">https://docs.haskellstack.org/en/stable/yaml_configuration/#package-indices</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package-indices:</span><br><span class="line">- download-prefix: https://hackage.haskell.org/</span><br><span class="line">  hackage-security:</span><br><span class="line">    keyids:</span><br><span class="line">    - 0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d</span><br><span class="line">    - 1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42</span><br><span class="line">    - 280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833</span><br><span class="line">    - 2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201</span><br><span class="line">    - 2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3</span><br><span class="line">    - 51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921</span><br><span class="line">    - 772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d</span><br><span class="line">    - aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9</span><br><span class="line">    - fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0</span><br><span class="line">    key-threshold: 3 # number of keys required</span><br><span class="line"></span><br><span class="line">    # ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614</span><br><span class="line">    ignore-expiry: true</span><br></pre></td></tr></table></figure><br>换源完成后, 继续执行 <code>stack setup</code>. 初始化完成后使用 <code>stack update</code> 更新 <code>index.tar.gz</code> 文件. 更新该文件时可能会发生哈希检验错误, 参考 <a href="https://github.com/commercialhaskell/stack/issues/3052" target="_blank" rel="noopener">#3052</a> 和 <a href="https://github.com/commercialhaskell/stack/issues/3771" target="_blank" rel="noopener">#3771</a>, 反复进行删除 <code>C:\sr\pantry\hackage</code> 下的文件并再次执行 <code>stack update</code> 的操作直至成功为止. 如果该错误始终无法解决, 可以尝试使用别的镜像源. 在使用第二个镜像源时, 使用代理可加快下载速度. 以 SSR 代理的默认端口为例, 在 CMD 中执行 <code>set http_proxy=http://127.0.0.1:1080</code> 和 <code>set https_proxy=http://127.0.0.1:1080</code>. 注意只能在 CMD 中设置, 此法对 Powershell 无效.</p><h1 id="配置-HIE"><a href="#配置-HIE" class="headerlink" title="配置 HIE"></a>配置 HIE</h1><p>新建一个短路径 ( 如 <code>C:\hie</code> ) 用于克隆 HIE 仓库, 若要选择长路径可参考<a href="https://github.com/haskell/haskell-ide-engine#windows-specific-pre-requirements" target="_blank" rel="noopener">此处</a>. 克隆是通过递归子模块的方式进行的: <code>git clone https://github.com/haskell/haskell-ide-engine --recurse-submodules</code>. 克隆完成后, 可通过 <code>stack ./install.hs help</code> 查看操作指南, 此过程需要等待一段时间以安装一些必要文件. 等出现操作指南后, 可使用 <code>stack ./install.hs hie-8.6.5</code> 进行安装 HIE. 笔者没有采用 <code>stack ./install.hs hie</code> 进行安装, 若选择此项则安装的是支持当前最新的 GHC 版本 GHC 8.8.2 的 HIE. 在安装 HIE 过程中安装 <code>network</code> 库时可能出现拒绝许可的错误, 参考 <a href="https://github.com/commercialhaskell/stack/issues/5014" target="_blank" rel="noopener">#5014</a>, 可尝试将 CMD 的字符编码改为 utf-8 进行解决, 即在 CMD 中输入 <code>chcp 65001</code> 后继续执行 <code>stack ./install.hs hie-8.6.5</code>. 安装完成后, 在 VSCode 中安装 <code>Haskell Language Server</code> 插件. HIE 支持在悬停状态下从 haddock 中获取文档, 这一功能需要使用到 <code>hoogle</code> 数据库, 根据<a href="https://github.com/haskell/haskell-ide-engine#docs-on-hovercompletion" target="_blank" rel="noopener">文档</a>说明, 可以在 <code>C:\hie</code> 下使用 <code>stack --stack-yaml=stack-8.6.5.yaml exec hoogle generate</code> 来生成 <code>hoogle</code> 数据库. 现在使用 VSCode 打开一个使用 Stack 构建的项目文件夹时, 便能体验基于 HIE 的开发环境. 打开一个 <code>hs</code> 文件, 在 HIE 初始化的过程中, 可能会产生 <a href="https://github.com/haskell/haskell-ide-engine/issues/1616" target="_blank" rel="noopener">#1616</a> 错误, 可以通过先 <code>stack build</code> 整个项目文件, 再在 VSCode 中打开 <code>hs</code> 文件来解决.</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>笔者根据该<a href="https://github.com/bitemyapp/learnhaskell/blob/master/guide-zh_CN.md" target="_blank" rel="noopener">建议</a>选择使用 Stack 代替 Haskell Platform 进行 GHC 和库的管理, 便有了这次重新搭建开发环境的尝试. 中文社区基本没有可用的博客和说明, 大都语焉不详或早已过时. 尽管笔者仔细参考了官方文档, 在这次配置过程中仍踩了很多很多很多很多很多很多的坑, 但经过不断查阅社区资料后最终还是配置成功了. 笔者从多而繁杂的解决过程中选择了一些简单明了的方案总结在此文中, 希望能为同好们节省尝试的时间.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;本文是在 Windows 10 操作系统下使用 &lt;a href=&quot;https://docs.haskellstack.org/en/stable/README/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stack&lt;/a&gt; 搭建基于 &lt;a href=&quot;https://github.com/haskell/haskell-ide-engine&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell IDE Engine&lt;/a&gt; ( HIE ) 的 VSCode 开发环境的介绍. Stack ( &lt;a href=&quot;https://github.com/commercialhaskell/stack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub页面&lt;/a&gt; ) 是用于开发 Haskell 的一个交互平台, 可以用于安装 Haskell 的编译器和各种库, 也可以用于构建和测试项目. Stack 对库的版本管理一定程度上依赖于&lt;a href=&quot;https://docs.haskellstack.org/en/stable/yaml_configuration/#resolver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解析器&lt;/a&gt;的选择, 解析器支持 &lt;a href=&quot;https://github.com/commercialhaskell/lts-haskell&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LTS 快照&lt;/a&gt;, &lt;a href=&quot;https://github.com/commercialhaskell/stackage-nightly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stackage Nightly快照&lt;/a&gt;等多种格式对版本进行指定, 一个快照下的一个库只能拥有一个版本号, 可在 &lt;a href=&quot;https://www.stackage.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stackage 网站&lt;/a&gt;上查询不同 GHC 对应的最新 LTS 快照. 更多有关 Stack 的教程可以参考&lt;a href=&quot;https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用户文档&lt;/a&gt;. HIE 是一个针对不断增长的 Haskell 工具的一个通用接口, 它为编辑器和 IDE 提供了功能齐全的语言服务器协议服务, HIE 目前支持的最低 Stack 版本为 2.1.1, 它仍然在不断开发中.&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://loniceras.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://loniceras.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何理解模格?</title>
    <link href="http://loniceras.github.io/2019/10/23/%E7%90%86%E8%A7%A3%E6%A8%A1%E6%A0%BC/"/>
    <id>http://loniceras.github.io/2019/10/23/%E7%90%86%E8%A7%A3%E6%A8%A1%E6%A0%BC/</id>
    <published>2019-10-23T09:15:38.000Z</published>
    <updated>2019-10-30T08:21:05.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备部分"><a href="#预备部分" class="headerlink" title="预备部分"></a>预备部分</h1><p>本文分为两个部分讨论模格, 第一部分考察模格的定义和动机并给出一些实例, 第二部分介绍模格的主要性质和结构定理. 记号约定: 格 $ (L,\leq) $, $ x \vee y = \sup \{x,y\} $, $ x \wedge y = \inf \{x,y\} $, $ [x,y]=\{\,z \in L\,|\,x \leq z \leq y\,\} $. 覆盖关系 $ \sqsubset $ 满足 $ x \sqsubset y $ 当且仅当 $ x&lt;y $ 且对任意 $ z \in L $ 都有 $ x \leq z \leq y $ 蕴涵 $ z=x $ 或 $ z=y $. $ {\sqsubseteq} = {\sqsubset} \cup {\varDelta_L} $, $ \varDelta_L $ 为 $ L $ 上的单位关系. 模的 (modular) : $ (\forall x,y,z \in L) \; x \leq y \rightarrow (x \vee z) \wedge y = x \vee (z \wedge y) $. 实际上, 由于对任意格 $ L $ 都有 $ (\forall x,y,z \in L) \; x \leq y \rightarrow (x \vee z) \wedge y \geq x \vee (z \wedge y) $, 因此模格的定义可以精炼为 $ (\forall x,y,z \in L) \; x \leq y \rightarrow (x \vee z) \wedge y \leq x \vee (z \wedge y) $.</p><a id="more"></a><h1 id="模格的定义与实例"><a href="#模格的定义与实例" class="headerlink" title="模格的定义与实例"></a>模格的定义与实例</h1><p>令 $ a,b \in L $ 满足 $ a \leq b $. 一种朴素的想法是: 如何建立 $ L $ 中任意元素和任意选取的区间 $ [a,b] $ 之间的关系. 此时, 我们考虑映射 $ j_a \colon L \to L $ 满足对任意 $ z \in L $ 都有 $ j_a(z)=a \vee z $, 映射 $ m_b \colon L \to L $ 满足对任意 $ z \in L $ 都有 $ m_b(z)=b \wedge z $. 注意到映射 $ m_b \circ j_a $ 和映射 $ j_a \circ m_b $ 均可将 $ L $ 中任意元素映到 $ [a,b] $ 中, 这样我们的想法已经初步实现, 但 $ m_b \circ j_a(z) $ 和 $ j_a \circ m_b(z) $ 通常是不同的, 也就是说我们现在有两种不同的建立关系的方法, 具体地我们还有 $ m_b \circ j_a(z) \geq j_a \circ m_b(z) $, $ m_b \circ j_a(z) \in [z \wedge b,b] $, $ j_a \circ m_b(z) \in [a,a \vee z] $. 对于模格来说, 我们有 $ m_b \circ j_a(z) = j_a \circ m_b(z) $, 此时两种方法得到统一, 这一重要特点使得模格具有很多良好的性质. 另一方面, 模格是分配格的一种合理且自然的弱化, 可以证明格是分配的当且仅当 $ (\forall x,y,z \in L)\; (x \vee z) \wedge y \leq x \vee (z \wedge y) $. 这样就可以十分容易发现分配格蕴涵模格, 虽然证明是简单的, 但大部分格论专著或教材中并不会指出这一点, 证明可以参见 [Grä 11] . 模格的一种弱化是半模格 (semimodular), 它比模格具有更少的限制. 代数也为模格提供了一些重要的实例可以帮助我们感受模格的特点. 考虑群 $ (G,\cdot) $, 其全体正规子群构成的集合关于包含关系构成模格 $ (\operatorname{N}(G),\subseteq) $, 即 $ (\forall S,T,X \in \operatorname{N}(G))\; S \subseteq T \rightarrow (SX) \cap T = S (X \cap T) $. 事实上, 若 $ S,T $ 为 $ G $ 的正规子群, 则 $ S \wedge T=S \cap T $, $ S \vee T=ST $. 注: $ (\operatorname{N}(G),\subseteq) $ 的模格定义在群论中称为戴德金模律(Dedekind Modular Law), 并可以借助陪集的性质将该结论推广到 $ S,T,X $ 为 $ G $ 的子群的情况(见 [Rob 96]), 但应该注意的是由于子群的乘积并不能总成为子群的上确界, 因此在子群乘法运算下不能构成格, 更不可能是模格. 对于其他代数结构 (如模) 也有类似的结论.</p><h1 id="模格的性质"><a href="#模格的性质" class="headerlink" title="模格的性质"></a>模格的性质</h1><p>模格的最广为人知的一个等价判据是 $ L $ 不存在与 Pentagon ($ N_5 $) 同构的子格, 如<a href="https://pic4.zhimg.com/80/v2-98de114c6cb0c04353e338c0cfa8bd79_hd.jpg" target="_blank" rel="noopener">哈斯图</a>所示, $ m_b \circ j_a(z)=b $, $ j_a \circ m_b(z) =a $, 这明显与我们前面对模格的刻画是不符的. 事实上, $ N_5 $ 是最小的非模的格. 可以想象, 当 Pentagon 的哈斯图中的 $ a,b $ 合并为一个点 $ y $ 时 (形成一个菱形满足 $ p \sqsubset y \sqsubset q $ 且 $ p \sqsubset z \sqsubset q $), 此时符合了我们对模格的刻画, 我们也允许一个菱形内部存在多个共用上下端点的四边形 (存在除了 $ y,z $ 外满足 $ p \sqsubset ? \sqsubset q $ 的元素). 因此, 我们能够利用元素的相对补 (relative complement) 来刻画模格 [Rom 08]: 对任意 $ x,p,q \in L $, 若 $ x $ 存在关于 $ [p,q] $ 的相对补, 则 $ x $ 关于 $ [p,q] $ 的所有相对补构成的集合是反链. 例如, 菱形哈斯图中 $ x $ 关于 $ [p,q] $ 的所有相对补构成的集合为单元素集; 菱形哈斯图内部存在 $ n $ 个满足 $ p \sqsubset ? \sqsubset q $ 关系的元素时 $ x $ 关于 $ [p,q] $ 的所有相对补构成的集合有 $ n+1 $ 元素. 如果将菱形堆积起来形成的哈斯图对应的格也是模的. 因此, 我们就有了一个与戴德金转置原则密切相关的模格等价判据 [Rom 08]: 若 $ y,z \in L $, 则令映射 $ \varphi_y \colon [y \wedge z, z] \to [y,y \vee z] $ 满足对任意 $ x \in [y \wedge z, z] $ 都有 $ \varphi_y(x)=y \vee x $, 映射 $ \psi_z \colon [y,y \vee z] \to [y \wedge z, z] $ 满足对任意 $ x \in [y,y \vee z] $ 都有 $ \psi_z(x)=z \wedge x $. $ L $ 是模的, 当且仅当 $ (\forall y,z \in L) \; \psi_z \circ \varphi_y = \varDelta_{[y \wedge z, z]} $, 当且仅当 $ (\forall y,z \in L) \; \varphi_y \circ \psi_z = \varDelta_{[y,y \vee z]} $.</p><p>由于模格具有的良好性质, 许多经典的代数定理都有模格的表述, 部分定理的模格表述在将其推广至泛代数 ([Cohn 81]) 情形时发挥了重要作用. 前述的戴德金转置原则 (Dedekind’s Transposition Principle) 是菱形同构定理 (Diamond Isomorphism Theorem) 的格论表述, 其群论表述是广为人知的诺特同构定理中的一条. 和群论类似, 戴德金转置原则可以推导出蝴蝶引理 (Zassenhaus Lemma) 的格论表述. 合成列相关的施赖埃尔定理 (Schreier Refinement Theorem) 和若当-赫尔德定理 (Jordan-Hölder Theorem) 有格论表述. 直积分解相关的克鲁尔-施密特定理 (Krull-Schmidt Theorem) 也有格论表述, 其弱化形式称为库洛什-奥尔定理 (Kurosh-Ore Theorem). 下面用尽可能少的术语 (相应地, 更长的表述) 来介绍一下这些工作并给出参考文献, 先给出一些定义: 若 $ A,B $ 为 $ L $ 的链满足 $ A \subseteq B $, $ \min A=\min B $, $ \max A=\max B $, 则称 $ B $ 为 $ A $ 的加细. 若 $ B $ 为 $ A $ 的加细 (refinement), 且 $ A \subsetneqq B $, 则称 $ B $ 为 $ A $ 的真加细 (proper refinement). 若 $ A $ 不存在真加细, 则称 $ A $ 为不可加细 (unrefinable). 若 $ l $ 不为 $ L $ 的最小元, 且对任意 $ x,y \in L $ 都有 $ l=x \vee y $ 蕴涵 $ l=x $ 或 $ l=y $, 则称 $ l $ 为并不可约的 (join-irreducible).</p><ul><li><p>戴德金转置原则: 若 $ x,y \in L $ , 则存在格同构 $ [x \wedge y,x] \cong [y, x \vee y] $. 戴德金转置原则几乎是模格最重要的性质, 绝大多数格论的教材或专著都不会省略它. “对任意 $ x,y \in L $, 戴德金转置原则都成立”是我们前述的最后一个模格等价判据的弱化, 它仅能作为有限格和代数格的模格判据 [Grä 11]. 由于戴德金转置原则表现出的哈斯图是个菱形, 因此相关的同构定理也称为菱形同构定理. 以群论的菱形同构定理为例: 若 $ (G,\cdot) $ 为群, $ T $ 为 $ G $ 的子群, $ N $ 为 $ G $ 的子规子群, 则 $ T/(T \cap N) \cong TN/N $. 该定理表现出的哈斯图也是个菱形, 且 $ TN=\langle T \cup N \rangle=T \vee N $.</p></li><li><p>蝴蝶引理及其对偶: 若 $ x,x^{\prime},y,y^{\prime} \in L $ 满足 $ x^{\prime} \leq x $ 且 $ y^{\prime} \leq y $, 则存在格同构 $ [x^{\prime} \vee (x \wedge y^{\prime}), x^{\prime} \vee (x \wedge y)] \cong [(x^{\prime} \wedge y) \vee y^{\prime} (x \wedge y) \vee y^{\prime}] $ 和 $ [x \wedge (x^{\prime} \vee y^{\prime}), x \wedge (x^{\prime} \vee y)] \cong [(x^{\prime} \vee y^{\prime}) \wedge y, (x \vee y^{\prime}) \wedge y] $. 两者的哈斯图都形如蝴蝶, 只不过是互相颠倒的. 前者参考[Rut 65], 后者参考[Bly 05].</p></li><li><p>施赖埃尔定理: 若 $ C_1,C_2 $ 是 $ L $ 的链满足 $ \min C_1=\min C_2 $ 且 $ \max C_1=\max C_2 $, 则存在 $ C_1 $ 的加细 $ C_1^{\prime}=\{x_0,x_1,\ldots,x_m\} $, $ C_2 $ 的加细 $ C_2^{\prime}=\{y_0,y_1,\ldots,y_n\} $, 使得 $ x_0 \leq x_1 \leq \cdots \leq x_m $ 且 $ y_0 \leq y_1\leq \cdots \leq y_n $, $ m=n $ 且存在置换$ \sigma \in S_n $ 使得对任意 $ k \in \{1,\ldots,n\} $ 都有格同构 $ [x_{i-1},x_i] \cong [y_{\sigma(i)-1},y_{\sigma(i)}] $. 若当-赫尔德定理是施赖埃尔定理的一个特殊情况, 即 $ C_1,C_2 $ 均为不可加细的链的情况, 此时 $ C_1=C_1^{\prime} $ 且 $ C_2=C_2^{\prime} $. 但是不可加细的链并非总是存在的 (如格存在无限链的情况). 可以证明当格是有限长的 (finite length) 时, 不可加细的链总存在. 参考 [Cohn 81] 和 [Rut 65]. 在 [Grä 11] 中若当-赫尔德定理被推广至半模格.</p></li><li><p>库洛什-奥尔定理: 若$ x_1,x_2,\ldots,x_m,y_1,y_2,\ldots,y_n \in L $ 是并不可约的, 对任意 $ i \in \{1,\ldots,m\},j \in \{1,\ldots,n\} $ 都有 $ x_1 \vee \cdots \vee x_m \neq x_1 \vee \cdots \vee x_{i-1} \vee x_{i+1} \vee x_m $ 且 $ y_1 \vee \cdots \vee y_n \neq y_1 \vee \cdots \vee y_{j-1} \vee y_{j+1} \vee y_n $, $ l=x_1 \vee \cdots \vee x_m=y_1 \vee \cdots \vee y_n \in L $, 则 $ m=n $, 且存在置换 $ \sigma \in S_n $ 使得对任意 $ k \in \{1,\ldots,n\} $ 都有 $ l=x_{\sigma(1)} \vee \cdots \vee x_{\sigma(k)} \vee y_{\sigma(k+1)} \vee \cdots \vee y_{\sigma(n)} $, $ L $ 是分配的蕴涵 $ \{x_1,\ldots,x_m\}=\{y_1,\ldots,y_n\} $. 若 $ L $ 满足关于元素的降链条件, 则对任意 $ l \in L $, 都存在并不可约的 $ x_1,x_2,\ldots,x_m \in L $, 使得对任意 $ i \in \{1,2,\ldots,m\} $ 都有 $ l=x_1 \vee \cdots \vee x_m \neq x_1 \vee \cdots \vee x_{i-1} \vee x_{i+1} \vee x_m $. 参考 [Birk 67] ,[Cohn 81], [Bly 05] , [Grä 11], [Rom 08] . 不难发现该定理是群论中的克鲁尔-施密特定理的弱化版本, 但群论的克鲁尔-施密特定理还能刻画分解元素间的同构关系. [Cohn 81] 在更强的条件下 (有限长模格的最大元分解为无关集 (independent) 的上确界) 提供了库洛什-奥尔定理的一种强化 (类似克鲁尔-施密特定理), 在这种分解下对任意 $ x_i $都存在 $ y_j $ 使得两者具有相同的补.</p></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[Birk 67] G. Birkhoff. Lattice Theory (Third Edition). American Mathematical Society, 1967.<br>[Cohn 81] P. M. Cohn. Universal Algebra (Second Edition). D. Reidel Publishing Company, 1981.<br>[Bly 05] T. S. Blyth. Lattices and Ordered Algebraic Structures. Springer-Verlag, 2005.<br>[Grä 11] G. Grätzer. Lattice Theory: Foundation. Birkhäuser, 2011.<br>[Rob 96] D. J. S. Robinson. A Course in the Theory of Groups (Second Edition). Springer-Verlag, 1996.<br>[Rut 65] D. E. Rutherford. Introduction to Lattice Theory. Oliver and Boyd Ltd, 1965.<br>[Rom 08] S. Roman. Lattices and Ordered Sets. Springer-Verlag, 2008.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备部分&quot;&gt;&lt;a href=&quot;#预备部分&quot; class=&quot;headerlink&quot; title=&quot;预备部分&quot;&gt;&lt;/a&gt;预备部分&lt;/h1&gt;&lt;p&gt;本文分为两个部分讨论模格, 第一部分考察模格的定义和动机并给出一些实例, 第二部分介绍模格的主要性质和结构定理. 记号约定: 格 $ (L,\leq) $, $ x \vee y = \sup \{x,y\} $, $ x \wedge y = \inf \{x,y\} $, $ [x,y]=\{\,z \in L\,|\,x \leq z \leq y\,\} $. 覆盖关系 $ \sqsubset $ 满足 $ x \sqsubset y $ 当且仅当 $ x&amp;lt;y $ 且对任意 $ z \in L $ 都有 $ x \leq z \leq y $ 蕴涵 $ z=x $ 或 $ z=y $. $ {\sqsubseteq} = {\sqsubset} \cup {\varDelta_L} $, $ \varDelta_L $ 为 $ L $ 上的单位关系. 模的 (modular) : $ (\forall x,y,z \in L) \; x \leq y \rightarrow (x \vee z) \wedge y = x \vee (z \wedge y) $. 实际上, 由于对任意格 $ L $ 都有 $ (\forall x,y,z \in L) \; x \leq y \rightarrow (x \vee z) \wedge y \geq x \vee (z \wedge y) $, 因此模格的定义可以精炼为 $ (\forall x,y,z \in L) \; x \leq y \rightarrow (x \vee z) \wedge y \leq x \vee (z \wedge y) $.&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://loniceras.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://loniceras.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>浅谈“抽象”</title>
    <link href="http://loniceras.github.io/2019/05/02/%E6%B5%85%E8%B0%88%E6%8A%BD%E8%B1%A1/"/>
    <id>http://loniceras.github.io/2019/05/02/%E6%B5%85%E8%B0%88%E6%8A%BD%E8%B1%A1/</id>
    <published>2019-05-02T08:55:44.000Z</published>
    <updated>2019-10-23T09:51:41.863Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自 <a href="https://ncatlab.org/nlab/show/abstraction" target="_blank" rel="noopener">https://ncatlab.org/nlab/show/abstraction</a>.</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>抽象或一般化是数学研究的基本策略. 通过阐述一个论点或将一个概念置于“适当的普遍性”中, 我们不仅可以加强结论和拓宽适用性, 而且可以更清晰地察觉数学概念中真正重要的部分.</p><p>毫不夸张地说, 现代代数 (尤其是范畴代数) 的发展驱动力来源于提取数学结构的本质并置于公理化的一般框架中的需求. 这对诸如拓扑斯, 阿贝尔范畴, 概形, 上同调理论和其他无数概念都是正确的.</p><p>寻找概念的“正确”推广 (而不仅仅是极大推广) 是一个辩证的过程, 严格逻辑意义上的一般化程度必须与简单性, 易用性, 启发性, 优美程度等其他因素相平衡. 对概念坚持不懈地打磨后, 一个集中了良好选择的定义的理论形成了, 关键结论从这些定义中自然地产生.</p><p>在数学 (和物理学等) 的历史上, 抽象的推动力偶尔会受到质疑. 在某种程度上这可能是一种代际效应, 观念的转变和重新学习学科基础的压力可能会遭到长期习惯于陈旧观点的数学家的抵制. 另一种观点认为, 为了推广而推广是一项枯燥无味的工作, 因此典型的相对反应就是进一步的抽象应该“证明它们自己”, 例如能够解决古老的问题.<br><a id="more"></a></p><h1 id="抽象的模式"><a href="#抽象的模式" class="headerlink" title="抽象的模式"></a>抽象的模式</h1><p>蜈蚣数学是指在不完全破坏某个现存数学概念功能的前提下删除其定义中的组成部分而形成的数学. Steven Krantz 将该词的产生归于 Antoni Zygmund. 引自 <a href="http://books.google.com/books?id=LMC5UeaStKwC&amp;pg=PA6&amp;lpg=PA6&amp;dq=%22centipede+mathematics%22&amp;source=bl&amp;ots=aivICIZzMU&amp;sig=2rMkg3u6tMhjQyfI-C46BZThiyk&amp;hl=en&amp;ei=kF46Ss_vC4yMsgPb0JD-Bg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=9" target="_blank" rel="noopener">Mathematical Apocrypha Redux</a>:“你将一个蜈蚣 (译注: 也可译作百足虫) 的 99 条腿拔掉, 看看它能做什么.”(我们不建议对真的蜈蚣这么做, 除非它是一个<a href="http://www.washingtonpost.com/wp-dyn/content/article/2007/05/05/AR2007050501009.html?hpid=topnews" target="_blank" rel="noopener">扫雷机器人</a>.)</p><p>例如, 我们从交换群的概念开始, 并尝试删除其中的一部分东西:</p><ul><li>删除交换律可以获得群;</li><li>接着, 删除逆元可以获得幺半群;</li><li>或者, 不删除逆元, 而删除结合律可以获得幺拟群;</li><li>等等 (参见群的条目).</li></ul><p>什么仍然起作用? 阿贝尔群构成阿贝尔范畴, 但群只构成半阿贝尔范畴, 因此上同调变得更加复杂 (参见非阿贝列上同调的条目), 但仍然有意义. 幺半群表示 (例如在向量空间上) 和群表示一样有意义, 但幺拟群表示没有显然的意义. (但就像非阿贝尔上同调一样, 也许有一天有人会使它们变得有意义.) 描述幺半群的同态和表现要比描述群的情况更加小心, 但简单的定义仍然适用于幺拟群. 有时事情会变得更好; 群对象仅在笛卡尔幺半范畴中有意义, 而幺半群对象在任何幺半范畴中都有意义. 通过研究使上同调和表示论这类事务变得有意义的特征, 我们发现我们可以概括这些特征, 这并不是简单地从群的定义中删除内容, 而是将概念重新加工为诸如范畴或量子群的概念.</p><p>蜈蚣数学在有关数学基础的中常被称为反推数学. 此时, 我们删除集合论 (或其他形式的基础) 中的一些公理, 并考虑哪些定理仍然能够被证明, 哪些定理能够在重新构造成 (显然的) 古典等价形式后被证明，哪些定理完全失效了 (它们在理想情况下应该被证明). 在 Lab (译注: 指该网站), 我们中的一些人为了构造性数学而常这样做, 但这对内化也很重要. (主流的反推数学更多地与直谓数学和高阶算术子系统相关, 而不是这两种数学.)</p><p>和“一般的抽象废话”(译注: 指范畴论) 一样, “蜈蚣数学”一词既可以是半开玩笑的, 也可以是贬义的. 当然, 证明诸如“偏亚半连续函数是莱布尼兹可积的.”的孤立定理对从没有真正需要以该限制性方式对该类一般函数进行积分的人来说是毫无价值的 (此处的两个术语都是编造的, 以免侮辱任何现实生活中无用定理的创造者). 但有时, 思考什么才是真正必要的会为真正卓有成效的一般化指明道路; 如同数学中的每一个判断, 良好的品味是必需的.</p><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>引自 <a href="https://ncatlab.org/nlab/show/Lawvere" target="_blank" rel="noopener">Lawvere</a>, 在 <a href="https://ncatlab.org/nlab/show/abstraction#picado" target="_blank" rel="noopener">An interview with F. William Lawvere</a> 中:</p><blockquote><p>对不断发展的数学的本质进行总结的基本工具是什么? 代数! 当我们用有限个公理表示范畴的元范畴时, 我们所知道的一切都可以表示为一种代数, 这类研究就产生了节点. 我很自豪能与 Eilenberg, Mac Lane, Freyd 以及许多其他人一起带来将当代代数作为范畴论的意识.</p></blockquote><p>引自 <a href="https://ncatlab.org/nlab/show/abstraction#reid" target="_blank" rel="noopener">Miles Reid</a>, p. 123:</p><blockquote><p>当时的许多学生显然想不出比研究 EGAs 还高的志向了. 对范畴理论本身的研究 (当然这是所有对智力的追求中最枯燥无味的一个) 也可以追溯到这个时期; Grothendieck 不应该因此受到指责, 因为他能很成功地使用范畴解决问题.</p></blockquote><p>引自 <a href="https://ncatlab.org/nlab/show/Tom+Leinster" target="_blank" rel="noopener">Tom Leinster</a>, 原引自 Reid , <a href="https://ncatlab.org/nlab/show/abstraction#leinster" target="_blank" rel="noopener">Leinster2010</a>:</p><blockquote><p>我很喜欢这句话，虽然不是出于 Reid 的本意. “Sterile”不仅意味着不肥沃或无生产力. 它同时也是对你想要的手术器械的要求: 干净, 无污染, 无疾病. 没有人愿意被脏手术刀做手术.</p><p>我要澄清这一点, 因为我能听到一个讽刺的声音说: “哦, 所以你想做的范畴论是不受实际数学污染的”. 我认为, 范畴论作为数学中的数学在其最佳状态发挥作用时, 不仅能反映数学家的实际工作, 而且能展示如何做得更好.</p></blockquote><p>引自 <a href="https://ncatlab.org/nlab/show/Categories+for+the+Working+Mathematician" target="_blank" rel="noopener">Categories for the Working Mathematician</a>, p. 108:</p><blockquote><p>人们可以推测为什么伴随函子的发现如此之晚. (…) Bourbaki 只不过错过了. (…) Bourbaki 的通用构造的思想被设计得如此一般化以至于包含了更多 (比找到左伴随更为广泛的问题). (…) (他的)公式缺乏伴随问题的对称性, 因此错过一个基本的发现; 这一发现留给了一个更年轻的人, 也许这个人对传统或流行不那么感激. 换句话说, 好的一般性理论不是寻找最大程度的推广, 而是寻找正确的推广.</p></blockquote><h1 id="译后记"><a href="#译后记" class="headerlink" title="译后记"></a>译后记</h1><p>译者首次接触较为抽象的数学是本科内容的抽象代数 (群和交换环简介), 学习时被其抽象凝练的特点及其具有的普遍适用性折服. 自此以后, 译者又学习了群论, 非交换环论和模论, 格论, 半群理论, 准环理论, 系理论等一系列代数结构理论, 伴随着结构所需假设的减少, 结论的一般化程度在增强, 而优雅程度也在减弱. 虽然译者早已知道一部分数学工作者对具有“semi-”, “hemi-”, “demi-” , “quasi-”, “near-”, “pseudo-”, “para-”等词头的数学结构颇有微词, 但译者在阅读此文时发现了<em>蜈蚣数学 (Centipede mathematics)</em> 这一颇具调侃意味的名称时仍惊讶了一番, 惊讶之余翻译了此文与大家共享. 由于译者的水平有限, 译文的缺点和错误在所难免, 真诚地希望读者批评指正.</p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Abstraction or generalization is a basic tactic in mathematics research. By formulating an argument or placing a concept in ‘proper generality’, one not only strengthens results and widens applicability, but one also perceives much more clearly what is truly at stake within the sphere of concepts where the mathematics takes place.</p><p>Without too much of an exaggeration, one could say that the development of modern algebra generally, and categorical algebra in particular, has been driven by the need to extract the essence of mathematical structures and situate them within axiomatic frameworks of general type. This is certain true of such concepts as topos, abelian category, scheme, cohomology theory, and countless others.</p><p>Finding the ‘right’ generality (as opposed to merely maximal generality) of concepts is a kind of dialectical process, in which generality in the strictly logical sense must be balanced against other considerations such as simplicity, ease of application, suggestiveness, aesthetics, etc. The result of such persistent conceptual polishing is often a theory that becomes concentrated in its well-chosen definitions, from which key summary results flow naturally.</p><p>Occasionally throughout the history of mathematics (and physics, etc.), the drive to abstraction has met with suspicion. To some extent this may be a generational phenomenon, where shifting conceptual landscapes and pressure to relearn the foundations of a subject may meet with resistance from mathematicians long accustomed to older insights. There can also be justice in the charge that generality for the sake of generality is a sterile pursuit, and a typical counter-reaction is that further layers of abstraction should “prove themselves”, e.g., by leading to solutions of venerable problems.</p><h2 id="Styles-of-abstraction"><a href="#Styles-of-abstraction" class="headerlink" title="Styles of abstraction"></a>Styles of abstraction</h2><p>Centipede mathematics is where you take an extant mathematical concept and see how many parts you can strip away without completely destroying its ability to function properly. Steven Krantz has attributed this term to Antoni Zygmund. From Mathematical Apocrypha Redux: ‘You take a centipede and pull off ninety-nine of its legs and see what it can do.’ (We do not recommend doing this to an actual centipede, unless it is a land-mine destroying robot.)</p><p>For example, you can start with the concept of abelian group and try removing some things:</p><ul><li>remove commutativity to get groups;</li><li>then remove inverses to get monoids;</li><li>or remove associativity instead of inverses to get loops;</li><li>etc (see group for more).</li></ul><p>What still works? Abelian groups form an abelian category, while groups only form a semi-abelian category, so cohomology gets more complicated (see nonabelian cohomology) but still makes sense. Monoid representations (say on vector spaces) make as much sense as group representations, but loop representations are not apparently meaningful. (But like nonabelian cohomology, maybe somebody will make sense of them some day.) Describing homomorphisms and presentations of monoids takes a little more care than for groups, while the naïve definitions continue to work for loops. Sometimes things actually work better; group objects make sense only in a cartesian monoidal category, while monoid objects make sense in any monoidal category. By seeing what are the salient features for making sense of things like cohomology and representation theory, we also see that we can generalise these, not by simply removing clauses from the definition of group, but by reworking the concept into such things as categories or quantum groups.</p><p>Centipede mathematics in the context of foundations is often called reverse mathematics. Here we remove axioms from set theory (or some other form of foundations) and consider what theorems can still be proved, which can be proved if reformulated into (obviously) classically equivalent forms, and which are lost entirely (ideally provably so). On the Lab, some of us like to do this for constructive mathematics, but it is also important for internalization. (Mainstream reverse mathematics has more to do with predicative mathematics than with either of these and works with subsystems of higher-order arithmetic.)</p><p>Like ‘general abstract nonsense’, the term ‘centipede mathematics’ can vary from tongue-in-cheek to derogatory. Certainly there is little value in proving isolated theorems like ‘Hemidemisemicontinuous functions are Leibniz-integrable.’ when one never really needs to integrate such general functions in such a restrictive way (both terms here are made up, to avoid insulting the creators of any real-life useless theorems). But sometimes thinking about what is really necessary points the way to really fruitful generalisations; like every judgement in mathematics, good taste is required.</p><h2 id="Illustrative-quotes"><a href="#Illustrative-quotes" class="headerlink" title="Illustrative quotes"></a>Illustrative quotes</h2><p>From Lawvere, in An interview with F. William Lawvere:</p><blockquote><p>What is the primary tool for such summing up of the essence of ongoing mathematics? Algebra! Nodal points in the progress of this kind of research occur when, as in the case with the finite number of axioms for the metacategory of categories, all that we know so far can be expressed in a single sort of algebra. I am proud to have participated with Eilenberg, Mac Lane, Freyd, and many others, in bringing about the contemporary awareness of Algebra as Category Theory.</p></blockquote><p>From Miles Reid, p. 123:</p><blockquote><p>Many students of the time could apparently not think of any higher ambition than Étudier les EGAs. The study of category theory for its own sake (surely one of the most sterile of all intellectual pursuits) also dates from this time; Grothendieck himself can’t necessarily be blamed for this, since his own use of categories was very successful in solving problems.</p></blockquote><p>From Tom Leinster, referring to the quotation from Reid, Leinster2010:</p><blockquote><p>I’ve become rather fond of that quotation, though not for the reason that Reid intended. ‘Sterile’ doesn’t only mean infertile or unproductive. It’s also what you want surgical instruments to be: clean, uncontaminated, disease-free. No one wants to be operated on with a dirty scalpel.</p><p>I’m going to clarify that point, because I can hear a sarcastic voice saying ‘oh, so you want to do category theory uncontaminated by real mathematics’. Category theory is at its best, I think, when it reflects what mathematicians actually do and shows how to do it better, when it functions as the mathematics of mathematics.</p></blockquote><p>From Categories for the Working Mathematician, p. 108:</p><blockquote><p>One may speculate as to why the discovery of adjoint functors was so delayed. (…) Bourbaki just missed… Bourbaki’s idea of universal construction was devised to be so general as to include more [than the problem of finding a left adjoint] … [his] formulation lacks the symmetry of the adjunction problem … and so missed a basic discovery; this discovery was left to a younger man, perhaps one less beholden to tradition or to fashion. Put differently, good general theory does not search for the maximum generality, but for the right generality.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自 &lt;a href=&quot;https://ncatlab.org/nlab/show/abstraction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ncatlab.org/nlab/show/abstraction&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;抽象或一般化是数学研究的基本策略. 通过阐述一个论点或将一个概念置于“适当的普遍性”中, 我们不仅可以加强结论和拓宽适用性, 而且可以更清晰地察觉数学概念中真正重要的部分.&lt;/p&gt;
&lt;p&gt;毫不夸张地说, 现代代数 (尤其是范畴代数) 的发展驱动力来源于提取数学结构的本质并置于公理化的一般框架中的需求. 这对诸如拓扑斯, 阿贝尔范畴, 概形, 上同调理论和其他无数概念都是正确的.&lt;/p&gt;
&lt;p&gt;寻找概念的“正确”推广 (而不仅仅是极大推广) 是一个辩证的过程, 严格逻辑意义上的一般化程度必须与简单性, 易用性, 启发性, 优美程度等其他因素相平衡. 对概念坚持不懈地打磨后, 一个集中了良好选择的定义的理论形成了, 关键结论从这些定义中自然地产生.&lt;/p&gt;
&lt;p&gt;在数学 (和物理学等) 的历史上, 抽象的推动力偶尔会受到质疑. 在某种程度上这可能是一种代际效应, 观念的转变和重新学习学科基础的压力可能会遭到长期习惯于陈旧观点的数学家的抵制. 另一种观点认为, 为了推广而推广是一项枯燥无味的工作, 因此典型的相对反应就是进一步的抽象应该“证明它们自己”, 例如能够解决古老的问题.&lt;br&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://loniceras.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://loniceras.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="译作" scheme="http://loniceras.github.io/tags/%E8%AF%91%E4%BD%9C/"/>
    
  </entry>
  
</feed>
